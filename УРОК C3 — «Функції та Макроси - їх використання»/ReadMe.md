## Урок «Функції та Макроси — їх використання»

### Короткий опис
> Переходимо від громіздких графів до модульного, перевикористовуваного коду.  
> Ви навчитесь створювати та правильно застосовувати **Functions** і **Macros**, розуміти їхні відмінності, а також організовувати власні Blueprint Function / Macro Libraries.

| Блок | Що вивчаємо | Практика |
| :- | :- | :- |
| **Функції: основи** | Input/Output Pins, Pure vs Impure, Local Variables | Пишемо `ChangeHealth` із параметрами |
| **Макроси: основи** | Execution Flow Re-use, **Macro Input/Output**|  |

---

### Q&A

| Питання | Відповідь |
| --- | --- |
| **Коли обирати Macro замість Function?** | Макрос доцільний, коли треба захопити *ланцюжок* виконання (кілька Exec-пінів) або зробити Latent Flow (Delay). Якщо потрібне повернення значення — беріть Function. |
| **Чи впливають Pure-функції на продуктивність?** | Так, Pure викликаються *кожного разу*, коли запитується їхній Pin → кешуйте результат у змінній, якщо дані не змінюються кожен кадр. |
| **Чому в Macros немає Local Variables?** | Макрос розгортається інлайн у місці виклику, тож Local Vars стають глобальними для контексту — щоб уникнути конфузу, їх прибрали. |
| **Чи можна викликати Blueprint-функцію з C++?** | Так, якщо вона `BlueprintCallable` (`UFUNCTION(BlueprintCallable)`). З Macros — ні, вони існують лише в BP-просторі. |

---

### Лайфхаки та рекомендації

- **Prefix-конвенція:** `Func_` для функцій, `M_` для макросів — одразу видно різницю в пошуку.  
- **Pure + Const:** ставте `Const` лише коли *жодна* змінна усередині не модифікується; інакше компілятор ігнорує прапорець.  
- **Collapse Graph:** спершу *Collapse to Function*, а не Macro — легше тестувати й документувати через Tooltip.  
- **Inlined Efficiency:** частий Exec-потік (Tick) віддавайте Macro-inline, а рідкі виклики (BeginPlay) — Function.  
- **Call in Editor:** функції з цією галочкою спрощують левел-арт (наприклад, `RandomizeMaterials()`) без запуску гри.

> **TL;DR:** Функція = повернення даних та інкапсуляція логіки; Макрос = перевикористання Exec-ланцюжка. Використовуйте їх усвідомлено, й ваші Blueprints перестануть виглядати як спагеті-код.
